# AuthButton 与 withPermissions 权限判断

## 1. 背景

`AuthButton` 是通过高阶组件 `withPermissions` 包装 `antd` 的 `Button` 得到的“带权限按钮”。
当用户权限不满足时，按钮不渲染（返回 `null`）。

当前项目已改为从 Redux store 读取按钮权限，不再依赖 `sessionStorage`。

## 2. 关键代码位置

- `src/pages/settings/index.tsx`
  - `const btnAuth = useSelector((state: RootState) => state.user.btnAuth)`
  - `const AuthButton = withPermissions(['delete'], btnAuth)(Button)`
- `src/utils/withPermissions.tsx`
  - 权限判断逻辑实现
- `src/store/userSlice.ts`
  - `btnAuth: string[]` 定义在 `user` slice 中
- `src/pages/login/index.tsx`
  - 登录成功后 `dispatch(setUser(res.data))`，将后端返回的 `btnAuth` 写入 store

## 3. AuthButton 的生成方式

示例（设置页）：

```tsx
const btnAuth = useSelector((state: RootState) => state.user.btnAuth)
const AuthButton = withPermissions(['delete'], btnAuth)(Button)
```

含义：

- `['delete']`：当前按钮要求的权限列表
- `btnAuth`：当前用户实际拥有的权限列表
- `AuthButton`：权限通过时表现为普通 `Button`，不通过时不显示

## 4. withPermissions 逻辑拆解

核心实现：

```tsx
/**
 * 
 * @param requiredPermissions 当前按钮所需要的权限
 * @param userPermissions 当前用户所拥有的权限
 */
function withPermissions(requiredPermissions: string[], userPermissions: string[]) {
  return function (Component: React.FC) {
    return function (props: any): React.ReactElement | null {
      const hasPermission = requiredPermissions.every((item) =>
        userPermissions.includes(item),
      )
      if (!hasPermission) return null
      return <Component {...props} />
    }
  }
}
```

判断规则：

- 使用 `every`，即“与（AND）”关系。
- 只有当 `requiredPermissions` 中每一项都在 `userPermissions` 里，才渲染组件。
- 任意一项不满足，组件返回 `null`（页面上不显示）。

## 5. 权限数据流（按钮权限）

1. 登录接口返回用户数据（含 `btnAuth`）。
2. `setUser` 写入 `user` slice（`state.user.btnAuth`）。
3. 页面通过 `useSelector` 读取 `state.user.btnAuth`。
4. `withPermissions` 对比“所需权限”和“用户权限”后决定是否渲染按钮。

## 6. 为什么优先用 store，而不是 sessionStorage

- 单一数据源：权限与登录态都在 Redux 管理，逻辑更集中。
- 类型更稳定：`btnAuth` 在 `userSlice` 中固定为 `string[]`，避免 `JSON.parse(null)` 这类运行时风险。
- 与现有架构一致：项目已通过 `redux-persist` 持久化 `user` slice，刷新后权限可恢复。

按钮权限存在 store 中，而不是 storage 中，可以避免安全问题。若刷新页面，store 中的数据丢失，就重新调用接口获取按钮权限数据。

菜单权限、路由权限 也是同理。

但是按钮权限，非要存在 storage 中也可以，因为每个按钮点击后都要调用接口，这就需要后端做一些校验，如用户是否真的有权限执行删除操作。

## 7. 使用注意

- `requiredPermissions` 传空数组时，`every` 会返回 `true`，组件会直接显示。
- 如果希望“满足任意一个权限即可显示”，需要把 `every` 改为 `some`。
- `withPermissions` 当前只做“前端显示控制”，真正安全控制仍应由后端接口鉴权负责。

# 登录权限控制

## 登录态来源与持久化

- 登录成功后在 `src/pages/login/index.tsx` 调用 `setUser` 写入 `user` slice，核心字段为 `token`（同时存用户名与 `btnAuth`）。
- store 通过 `redux-persist` 持久化（`src/store/index.ts` + `src/main.tsx` 的 `PersistGate`），刷新页面仍保留登录态。

## 路由守卫（是否已登录）

- `src/router/RequireAuth.tsx` 读取 `user.token`：
  - `needLogin=true` 且未登录时，重定向到 `/login`。
  - 已登录访问 `/login` 时，重定向到 `/`。
- `src/router/index.tsx` 配置：
  - `/login` 包裹 `RequireAuth`（不需要登录，但会拦截已登录用户）。
  - `/` 包裹 `RequireAuth needLogin`，其子路由默认都要求登录。

### RequireAuth.tsx 的实现细节

- 通过 `useSelector` 从 `RootState` 中读取 `user.token`，`Boolean(token)` 作为登录态判定。
- 使用 `useLocation` 读取当前路径；内部定义 `LOGIN_PATH = '/login'` 和 `DEFAULT_AUTHED_REDIRECT = '/'`。
- 逻辑顺序：
  1) `needLogin && !isLogin` 时 `<Navigate to="/login" replace />`，未登录强制跳转登录页。
  2) `isLogin && location.pathname === '/login'` 时 `<Navigate to="/" replace />`，已登录阻止回登录页。
  3) 其他情况直接渲染 `children`。

示例代码（摘自 `src/router/RequireAuth.tsx`）：

```tsx
function RequireAuth({ needLogin = false, children }: RequireAuthProps) {
  const token = useSelector((state: RootState) => state.user.token)
  const isLogin = Boolean(token)
  const location = useLocation()

  if (needLogin && !isLogin) {
    return <Navigate to="/login" replace />
  }

  if (isLogin && location.pathname === '/login') {
    return <Navigate to="/" replace />
  }

  return <>{children}</>
}
```

### RequireAuth 在路由中的使用方式

- `src/router/index.tsx` 在路由声明里直接包裹 `element`：
  - 登录页：`<RequireAuth><Login /></RequireAuth>`，仅用于“已登录用户重定向”。
  - 根路由：`<RequireAuth needLogin><PageLayout /></RequireAuth>`，要求登录后访问，子路由继承该限制。

示例代码（摘自 `src/router/index.tsx`）：

```tsx
const router = createBrowserRouter([
  {
    path: '/login',
    element: (
      <RequireAuth>
        <Login />
      </RequireAuth>
    ),
  },
  {
    path: '/',
    element: (
      <RequireAuth needLogin>
        <PageLayout />
      </RequireAuth>
    ),
    children: [
      { index: true, element: componentMap['/dashboard'] },
      { path: '*', element: <NotFound /> },
    ],
  },
])
```

## 菜单与动态路由（权限路由）

- `src/components/page-layout/menu-nav/MenuNav.tsx` 在有 token 时请求菜单：
  - `getMenuList(token)` 获取菜单并写入 store，同时调用 `addMenuRoutes` 动态补充路由。
  - 实际可访问的路由集合由菜单决定，菜单不同则路由不同。
- `src/router/dynamic-routes.ts` 将菜单转换为路由，并通过 `router.patchRoutes` 注入。
- mock 中通过 token 区分菜单（`src/mock/index.ts`），模拟角色权限差异。

## 请求鉴权

- `src/http/http.ts` 请求拦截器自动注入 `Authorization: Bearer <token>`。
- 菜单接口也显式携带 token 作为参数（`src/api/system.ts`）。

## 退出登录

- `src/components/page-layout/page-header/PageHeader.tsx` 点击退出登录后：
  - 清空 `user` 与 `system` store。
  - 跳转到 `/login`，触发路由守卫限制访问。
